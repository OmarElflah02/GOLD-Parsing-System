//Generated by the GOLD Parser Builder

using System.IO;
using System.Windows.Forms;

class MyParserclass
{
    private GOLD.Parser parser = new GOLD.Parser();
    public GOLD.Reduction Root;
    public string ErrorMessage;

    private enum SymbolIndex
    {
        @Eof = 0,                                  // (EOF)
        @Error = 1,                                // (Error)
        @Whitespace = 2,                           // Whitespace
        @Minus = 3,                                // '-'
        @Minusminus = 4,                           // '--'
        @Exclameq = 5,                             // '!='
        @Percent = 6,                              // '%'
        @Lparen = 7,                               // '('
        @Rparen = 8,                               // ')'
        @Times = 9,                                // '*'
        @Timestimes = 10,                          // '**'
        @Div = 11,                                 // '/'
        @Semi = 12,                                // ';'
        @Lbrace = 13,                              // '{'
        @Rbrace = 14,                              // '}'
        @Plus = 15,                                // '+'
        @Plusplus = 16,                            // '++'
        @Lt = 17,                                  // '<'
        @Eq = 18,                                  // '='
        @Eqeq = 19,                                // '=='
        @Gt = 20,                                  // '>'
        @Digit = 21,                               // Digit
        @Double = 22,                              // double
        @Else = 23,                                // else
        @End = 24,                                 // End
        @Float = 25,                               // float
        @For = 26,                                 // For
        @Id = 27,                                  // Id
        @If = 28,                                  // if
        @Int = 29,                                 // int
        @Start = 30,                               // Start
        @String = 31,                              // string
        @Assign = 32,                              // <assign>
        @Concept = 33,                             // <concept>
        @Cond = 34,                                // <cond>
        @Data = 35,                                // <data>
        @Digit2 = 36,                              // <digit>
        @Exp = 37,                                 // <exp>
        @Expr = 38,                                // <expr>
        @Factor = 39,                              // <factor>
        @For_stmt = 40,                            // <for_stmt>
        @Id2 = 41,                                 // <id>
        @If_stmt = 42,                             // <if_stmt>
        @Op = 43,                                  // <op>
        @Program = 44,                             // <program>
        @Step = 45,                                // <step>
        @Stmt_list = 46,                           // <stmt_list>
        @Term = 47                                 // <term>
    }

    private enum ProductionIndex
    {
        @Program_Start_End = 0,                    // <program> ::= Start <stmt_list> End
        @Stmt_list = 1,                            // <stmt_list> ::= <concept>
        @Stmt_list2 = 2,                           // <stmt_list> ::= <concept> <stmt_list>
        @Concept = 3,                              // <concept> ::= <assign>
        @Concept2 = 4,                             // <concept> ::= <if_stmt>
        @Concept3 = 5,                             // <concept> ::= <for_stmt>
        @Assign_Eq_Semi = 6,                       // <assign> ::= <id> '=' <expr> ';'
        @Id_Id = 7,                                // <id> ::= Id
        @Expr_Plus = 8,                            // <expr> ::= <term> '+' <expr>
        @Expr_Minus = 9,                           // <expr> ::= <term> '-' <expr>
        @Expr = 10,                                // <expr> ::= <term>
        @Term_Times = 11,                          // <term> ::= <factor> '*' <term>
        @Term_Div = 12,                            // <term> ::= <factor> '/' <term>
        @Term_Percent = 13,                        // <term> ::= <factor> '%' <term>
        @Term = 14,                                // <term> ::= <factor>
        @Factor_Timestimes = 15,                   // <factor> ::= <exp> '**' <factor>
        @Factor = 16,                              // <factor> ::= <exp>
        @Exp_Lparen_Rparen = 17,                   // <exp> ::= '(' <expr> ')'
        @Exp = 18,                                 // <exp> ::= <id>
        @Exp2 = 19,                                // <exp> ::= <digit>
        @Digit_Digit = 20,                         // <digit> ::= Digit
        @If_stmt_If_Lparen_Rparen_Start_End = 21,  // <if_stmt> ::= if '(' <cond> ')' Start <stmt_list> End
        @If_stmt_If_Lparen_Rparen_Start_End_Else = 22,  // <if_stmt> ::= if '(' <cond> ')' Start <stmt_list> End else <stmt_list>
        @Cond = 23,                                // <cond> ::= <expr> <op> <expr>
        @Op_Lt = 24,                               // <op> ::= '<'
        @Op_Gt = 25,                               // <op> ::= '>'
        @Op_Eqeq = 26,                             // <op> ::= '=='
        @Op_Exclameq = 27,                         // <op> ::= '!='
        @For_stmt_For_Lparen_Semi_Semi_Rparen_Lbrace_Rbrace = 28,  // <for_stmt> ::= For '(' <data> <assign> ';' <cond> ';' <step> ')' '{' <stmt_list> '}'
        @Data_Int = 29,                            // <data> ::= int
        @Data_Float = 30,                          // <data> ::= float
        @Data_Double = 31,                         // <data> ::= double
        @Data_String = 32,                         // <data> ::= string
        @Step_Minusminus = 33,                     // <step> ::= '--' <id>
        @Step_Minusminus2 = 34,                    // <step> ::= <id> '--'
        @Step_Plusplus = 35,                       // <step> ::= '++' <id>
        @Step_Plusplus2 = 36,                      // <step> ::= <id> '++'
        @Step = 37                                 // <step> ::= <assign>
    }

    public object program;     //You might derive a specific object

    public void Setup()
    {
        //This procedure can be called to load the parse tables. The class can
        //read tables using a BinaryReader.
        
        parser.LoadTables(Path.Combine(Application.StartupPath, "pgram.egt"));
    }
    
    public bool Parse(TextReader reader)
    {
        //This procedure starts the GOLD Parser Engine and handles each of the
        //messages it returns. Each time a reduction is made, you can create new
        //custom object and reassign the .CurrentReduction property. Otherwise, 
        //the system will use the Reduction object that was returned.
        //
        //The resulting tree will be a pure representation of the language 
        //and will be ready to implement.

        GOLD.ParseMessage response; 
        bool done;                      //Controls when we leave the loop
        bool accepted = false;          //Was the parse successful?

        parser.Open(reader);
        parser.TrimReductions = false;  //Please read about this feature before enabling  

        done = false;
        while (!done)
        {
            response = parser.Parse();

            switch (response)
            {
                case GOLD.ParseMessage.LexicalError:
                    //Cannot recognize token
                    ErrorMessage = "lexical Error founded " + "\n" + "can't draw parse tree" ;
                    done = true;
                    break;

                case GOLD.ParseMessage.SyntaxError:
                    //Expecting a different token
                    ErrorMessage = "Syntax Error founded " + "\n" + "can't draw parse tree";
                    done = true;
                    break;

                case GOLD.ParseMessage.Reduction:
                    //Create a customized object to store the reduction

                  //  parser.CurrentReduction = CreateNewObject(parser.CurrentReduction as GOLD.Reduction);
                    break;

                case GOLD.ParseMessage.Accept:
                    //Accepted!
                    //program = parser.CurrentReduction   //The root node!                 
                    Root = (GOLD.Reduction)parser.CurrentReduction;
                    done = true;
                    accepted = true;
                    break;

                case GOLD.ParseMessage.TokenRead:
                    //You don't have to do anything here.
                    break;

                case GOLD.ParseMessage.InternalError:
                    //INTERNAL ERROR! Something is horribly wrong.
                    done = true;
                    break;

                case GOLD.ParseMessage.NotLoadedError:
                    //This error occurs if the CGT was not loaded.                   
                    done = true;
                    break;

                case GOLD.ParseMessage.GroupError: 
                    //GROUP ERROR! Unexpected end of file
                    done = true;
                    break;
            } 
        } //while

        return accepted;
    }
    
    private object CreateNewObject(GOLD.Reduction r)
    { 
        object result = null;
        
        switch ( (ProductionIndex) r.Parent.TableIndex())
        {
            case ProductionIndex.Program_Start_End:                 
                // <program> ::= Start <stmt_list> End
                break;

            case ProductionIndex.Stmt_list:                 
                // <stmt_list> ::= <concept>
                break;

            case ProductionIndex.Stmt_list2:                 
                // <stmt_list> ::= <concept> <stmt_list>
                break;

            case ProductionIndex.Concept:                 
                // <concept> ::= <assign>
                break;

            case ProductionIndex.Concept2:                 
                // <concept> ::= <if_stmt>
                break;

            case ProductionIndex.Concept3:                 
                // <concept> ::= <for_stmt>
                break;

            case ProductionIndex.Assign_Eq_Semi:                 
                // <assign> ::= <id> '=' <expr> ';'
                break;

            case ProductionIndex.Id_Id:                 
                // <id> ::= Id
                break;

            case ProductionIndex.Expr_Plus:                 
                // <expr> ::= <term> '+' <expr>
                break;

            case ProductionIndex.Expr_Minus:                 
                // <expr> ::= <term> '-' <expr>
                break;

            case ProductionIndex.Expr:                 
                // <expr> ::= <term>
                break;

            case ProductionIndex.Term_Times:                 
                // <term> ::= <factor> '*' <term>
                break;

            case ProductionIndex.Term_Div:                 
                // <term> ::= <factor> '/' <term>
                break;

            case ProductionIndex.Term_Percent:                 
                // <term> ::= <factor> '%' <term>
                break;

            case ProductionIndex.Term:                 
                // <term> ::= <factor>
                break;

            case ProductionIndex.Factor_Timestimes:                 
                // <factor> ::= <exp> '**' <factor>
                break;

            case ProductionIndex.Factor:                 
                // <factor> ::= <exp>
                break;

            case ProductionIndex.Exp_Lparen_Rparen:                 
                // <exp> ::= '(' <expr> ')'
                break;

            case ProductionIndex.Exp:                 
                // <exp> ::= <id>
                break;

            case ProductionIndex.Exp2:                 
                // <exp> ::= <digit>
                break;

            case ProductionIndex.Digit_Digit:                 
                // <digit> ::= Digit
                break;

            case ProductionIndex.If_stmt_If_Lparen_Rparen_Start_End:                 
                // <if_stmt> ::= if '(' <cond> ')' Start <stmt_list> End
                break;

            case ProductionIndex.If_stmt_If_Lparen_Rparen_Start_End_Else:                 
                // <if_stmt> ::= if '(' <cond> ')' Start <stmt_list> End else <stmt_list>
                break;

            case ProductionIndex.Cond:                 
                // <cond> ::= <expr> <op> <expr>
                break;

            case ProductionIndex.Op_Lt:                 
                // <op> ::= '<'
                break;

            case ProductionIndex.Op_Gt:                 
                // <op> ::= '>'
                break;

            case ProductionIndex.Op_Eqeq:                 
                // <op> ::= '=='
                break;

            case ProductionIndex.Op_Exclameq:                 
                // <op> ::= '!='
                break;

            case ProductionIndex.For_stmt_For_Lparen_Semi_Semi_Rparen_Lbrace_Rbrace:                 
                // <for_stmt> ::= For '(' <data> <assign> ';' <cond> ';' <step> ')' '{' <stmt_list> '}'
                break;

            case ProductionIndex.Data_Int:                 
                // <data> ::= int
                break;

            case ProductionIndex.Data_Float:                 
                // <data> ::= float
                break;

            case ProductionIndex.Data_Double:                 
                // <data> ::= double
                break;

            case ProductionIndex.Data_String:                 
                // <data> ::= string
                break;

            case ProductionIndex.Step_Minusminus:                 
                // <step> ::= '--' <id>
                break;

            case ProductionIndex.Step_Minusminus2:                 
                // <step> ::= <id> '--'
                break;

            case ProductionIndex.Step_Plusplus:                 
                // <step> ::= '++' <id>
                break;

            case ProductionIndex.Step_Plusplus2:                 
                // <step> ::= <id> '++'
                break;

            case ProductionIndex.Step:                 
                // <step> ::= <assign>
                break;

        }  //switch

        return result;
    }
    
}; //MyParser
